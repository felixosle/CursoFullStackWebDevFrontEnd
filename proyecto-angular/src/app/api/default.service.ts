/**
 * API Reserva de Salas
 * Definición de una API sencilla de reserva de salas para fines educativos. Cuenta con 5 tipos principales de objeto: Usuarios, Reservas, Edificios, Salas y Recursos (comentado)
 *
 * OpenAPI spec version: SinSeguridad
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams }               from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { Edificio } from '../model/edificio';
import { Reserva } from '../model/reserva';
import { Sala } from '../model/sala';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';


@Injectable()
export class DefaultService {

    protected basePath = 'https://virtserver.swaggerhub.com/felixosle/ReservaSala/1.1.0';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Actualizar edificio
     * 
     * @param idEdificio ID del edificio a actualizar
     * @param edificio Nuevos Datos del edificio
     */
    public actualizarEdificio(idEdificio: number, edificio: Edificio): Observable<{}> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling actualizarEdificio.');
        }
        if (edificio === null || edificio === undefined) {
            throw new Error('Required parameter edificio was null or undefined when calling actualizarEdificio.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}`,
            edificio,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Actualizar Reserva por ID
     * 
     * @param idReserva ID de la reserva a actualizar
     * @param reserva Nuevos Datos de la reserva
     */
    public actualizarReserva(idReserva: number, reserva: Reserva): Observable<{}> {
        if (idReserva === null || idReserva === undefined) {
            throw new Error('Required parameter idReserva was null or undefined when calling actualizarReserva.');
        }
        if (reserva === null || reserva === undefined) {
            throw new Error('Required parameter reserva was null or undefined when calling actualizarReserva.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/reservas/${encodeURIComponent(String(idReserva))}`,
            reserva,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Actualizar sala
     * Actualiza una sala
     * @param idEdificio ID del edificio a recuperar
     * @param idSala ID de la sala a actualizar
     * @param sala Nuevos Datos de la sala
     */
    public actualizarSala(idEdificio: number, idSala: number, sala: Sala): Observable<{}> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling actualizarSala.');
        }
        if (idSala === null || idSala === undefined) {
            throw new Error('Required parameter idSala was null or undefined when calling actualizarSala.');
        }
        if (sala === null || sala === undefined) {
            throw new Error('Required parameter sala was null or undefined when calling actualizarSala.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}/salas/${encodeURIComponent(String(idSala))}`,
            sala,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Agregar edificio
     * Agrega un edificio al sistema
     * @param body Datos del nuevo edificio
     */
    public agregarEdificio(body: Edificio): Observable<{}> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling agregarEdificio.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/edificios`,
            body,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Agregar reserva
     * Agrega una reserva al sistema
     * @param reserva Datos de la nueva reserva
     */
    public agregarReserva(reserva: Reserva): Observable<{}> {
        if (reserva === null || reserva === undefined) {
            throw new Error('Required parameter reserva was null or undefined when calling agregarReserva.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/reservas`,
            reserva,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Agregar sala
     * Agrega una sala al sistema
     * @param idEdificio ID del edificio a recuperar
     * @param body Datos de la nueva sala
     */
    public agregarSala(idEdificio: number, body?: Sala): Observable<{}> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling agregarSala.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}/salas`,
            body,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Borra un edificio
     * 
     * @param idEdificio ID del edificio a borrar
     */
    public borrarEdificio(idEdificio: number): Observable<{}> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling borrarEdificio.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Borra una reserva por ID
     * 
     * @param idReserva ID de la reserva a borrar
     */
    public borrarReservaPorID(idReserva: number): Observable<{}> {
        if (idReserva === null || idReserva === undefined) {
            throw new Error('Required parameter idReserva was null or undefined when calling borrarReservaPorID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/reservas/${encodeURIComponent(String(idReserva))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Borra una sala
     * 
     * @param idEdificio ID del edificio a recuperar
     * @param idSala ID de la sala a borrar
     */
    public borrarSala(idEdificio: number, idSala: number): Observable<{}> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling borrarSala.');
        }
        if (idSala === null || idSala === undefined) {
            throw new Error('Required parameter idSala was null or undefined when calling borrarSala.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}/salas/${encodeURIComponent(String(idSala))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Busca edificios
     * Buúsqueda de edificios
     * @param searchString Pasa una cadena opcional para buscar edificios
     * @param skip Numero de registros que salta en cada paginacion
     * @param limit Numero maáximo de registros devueltos
     */
    public getEdificio(searchString?: string, skip?: number, limit?: number): Observable<Array<Edificio>> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (searchString !== undefined) {
            queryParameters = queryParameters.set('searchString', <any>searchString);
        }
        if (skip !== undefined) {
            queryParameters = queryParameters.set('skip', <any>skip);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/edificios`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Busca edificio por ID
     * Devuelve un edificio por ID
     * @param idEdificio ID del edificio a recuperar
     */
    public getEdificioPorId(idEdificio: number): Observable<Edificio> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling getEdificioPorId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Busca Reserva por ID
     * Devuelve una reserva por ID
     * @param idReserva ID de la reserva a recuperar
     */
    public getReservaPorId(idReserva: number): Observable<Reserva> {
        if (idReserva === null || idReserva === undefined) {
            throw new Error('Required parameter idReserva was null or undefined when calling getReservaPorId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/reservas/${encodeURIComponent(String(idReserva))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Busca reservas
     * Busqueda de reservas
     * @param searchString Pasa una cadena opcional para buscar reservas
     * @param offset Numero de registros que salta en cada paginacion
     * @param limit Numero máximo de registros devueltos
     */
    public getReservas(searchString?: string, offset?: number, limit?: number): Observable<Array<Reserva>> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (searchString !== undefined) {
            queryParameters = queryParameters.set('searchString', <any>searchString);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/reservas`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Busca Sala por ID
     * Devuelve una sala por ID
     * @param idEdificio ID del edificio a recuperar
     * @param idSala ID de la sala a recuperar
     */
    public getSalaPorId(idEdificio: number, idSala: number): Observable<Sala> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling getSalaPorId.');
        }
        if (idSala === null || idSala === undefined) {
            throw new Error('Required parameter idSala was null or undefined when calling getSalaPorId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}/salas/${encodeURIComponent(String(idSala))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Buscar salas
     * Busqueda de salas
     * @param idEdificio ID del edificio a recuperar
     * @param searchString Pasa una cadena opcional para buscar salas
     * @param skip numero de registros que salta en cada paginacion
     * @param limit Nuúmero maximo de registros devueltos
     */
    public getSalas(idEdificio: number, searchString?: string, skip?: number, limit?: number): Observable<Array<Sala>> {
        if (idEdificio === null || idEdificio === undefined) {
            throw new Error('Required parameter idEdificio was null or undefined when calling getSalas.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (searchString !== undefined) {
            queryParameters = queryParameters.set('searchString', <any>searchString);
        }
        if (skip !== undefined) {
            queryParameters = queryParameters.set('skip', <any>skip);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/edificios/${encodeURIComponent(String(idEdificio))}/salas`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Logs user into the system
     * 
     * @param email The user name for login
     * @param password The password for login in clear text
     */
    public loginUser(email: string, password: string): Observable<string> {
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling loginUser.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling loginUser.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/user/login`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Logs out current logged in user session
     * 
     */
    public logoutUser(): Observable<{}> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/user/logout`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Checks if the server is running
     * 
     */
    public pingGet(): Observable<{}> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/ping`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Home
     * 
     */
    public rootGet(): Observable<{}> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

}
